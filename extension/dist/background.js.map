{"version":3,"file":"background.js","sources":["../src/background.ts"],"sourcesContent":["const LOG_PREFIX = \"[Imagion Background]\";\r\nconst DEFAULT_DETECTION_ENDPOINT = \"http://localhost:3000/api/detect\";\r\nconst REQUEST_TTL_MS = 5 * 60 * 1000;\r\nconst MAX_CONCURRENT_DETECTIONS = 3;\r\nconst TELEMETRY_KEY = \"imagionTelemetry\";\nconst TELEMETRY_LIMIT = 40;\nconst BACKOFF_MIN_MS = 15000;\nconst BACKOFF_MAX_MS = 60000;\nconst HASH_HISTORY_KEY = \"recentImageHistory\";\nconst MAX_HASH_HISTORY = 250;\n\nconsole.log(LOG_PREFIX, \"Service worker started\");\n\r\ntype ImagionConfig = {\r\n  imagionApiKey: string;\r\n  imagionDetectionEndpoint: string;\r\n};\r\n\r\ntype DetectionResponsePayload = {\n  status: \"success\" | \"missing-key\" | \"error\" | \"rate-limit\";\n  verdict?: string;\n  score?: number;\n  confidence?: number;\n  presentation?: string;\n  message?: string;\n  badgeLabel?: string;\n  retryAfterSeconds?: number;\n};\n\ntype HashHistoryEntry = {\n  hash: string;\n  payload: DetectionResponsePayload;\n  createdAt: number;\n};\n\ntype DetectionResponse = DetectionResponsePayload & {\n  badgeId: string;\n  imageUrl: string;\n};\n\r\ntype PendingResolver = {\r\n  badgeId: string;\r\n  sendResponse: (response: DetectionResponse) => void;\r\n};\r\n\r\ntype PendingRequest = {\r\n  resolvers: PendingResolver[];\r\n};\r\n\r\ntype TelemetryEntry = {\r\n  timestamp: number;\r\n  level: \"info\" | \"warning\" | \"error\";\r\n  message: string;\r\n  details?: Record<string, unknown>;\r\n};\r\n\r\nconst cache = new Map<string, { timestamp: number; payload: DetectionResponsePayload }>();\r\nconst pendingRequests = new Map<string, PendingRequest>();\r\nconst detectionQueue: Array<{ imageUrl: string }> = [];\r\nconst telemetryEntries: TelemetryEntry[] = [];\nlet runningDetections = 0;\nlet cachedConfig: ImagionConfig | null = null;\nlet nextAllowedTimestamp = 0;\nlet backoffTimer: ReturnType<typeof setTimeout> | null = null;\nlet hashHistory: HashHistoryEntry[] = [];\nconst hashHistoryReady = loadHashHistory();\n\r\nasync function getConfig(): Promise<ImagionConfig> {\r\n  if (cachedConfig) {\r\n    return cachedConfig;\r\n  }\r\n\r\n  const config = await new Promise<ImagionConfig>((resolve) => {\r\n    chrome.storage.local.get(\r\n      {\r\n        imagionApiKey: \"\",\r\n        imagionDetectionEndpoint: DEFAULT_DETECTION_ENDPOINT,\r\n      },\r\n      (items) => {\r\n        resolve({\r\n          imagionApiKey: typeof items.imagionApiKey === \"string\" ? items.imagionApiKey.trim() : \"\",\r\n          imagionDetectionEndpoint:\r\n            typeof items.imagionDetectionEndpoint === \"string\" && items.imagionDetectionEndpoint.trim().length > 0\r\n              ? items.imagionDetectionEndpoint.trim()\r\n              : DEFAULT_DETECTION_ENDPOINT,\r\n        });\r\n      }\r\n    );\r\n  });\r\n\r\n  cachedConfig = config;\r\n  console.log(LOG_PREFIX, \"Config loaded:\", {\r\n    hasApiKey: !!config.imagionApiKey,\r\n    endpoint: config.imagionDetectionEndpoint,\r\n  });\r\n  return config;\r\n}\r\n\r\nchrome.storage.onChanged.addListener((changes, areaName) => {\r\n  if (areaName !== \"local\") {\r\n    return;\r\n  }\r\n  if (changes.imagionApiKey || changes.imagionDetectionEndpoint) {\r\n    console.log(LOG_PREFIX, \"Config changed, clearing cache\");\r\n    cachedConfig = null;\r\n  }\r\n});\r\n\r\nchrome.runtime.onMessage.addListener((message, _sender, sendResponse) => {\r\n  if (!message || message.type !== \"REQUEST_DETECTION\") {\r\n    return false;\r\n  }\r\n\r\n  console.log(LOG_PREFIX, \"Received detection request:\", message.badgeId, message.imageUrl?.substring(0, 80));\r\n  handleImageDetection(message, sendResponse);\r\n  return true;\r\n});\r\n\r\nfunction handleImageDetection(message: {\r\n  type: \"REQUEST_DETECTION\";\r\n  imageUrl: string;\r\n  badgeId: string;\r\n  pageUrl: string;\r\n}, sendResponse: (response: DetectionResponse) => void) {\r\n  const normalizedUrl = normalizeImageUrl(message.imageUrl, message.pageUrl);\r\n  if (!normalizedUrl) {\r\n    console.warn(LOG_PREFIX, \"Invalid URL:\", message.imageUrl);\r\n    sendResponse({\r\n      status: \"error\",\r\n      message: \"Unable to resolve image URL.\",\r\n      badgeId: message.badgeId,\r\n      imageUrl: message.imageUrl,\r\n    });\r\n    return;\r\n  }\r\n\r\n  const cached = getCachedResult(normalizedUrl);\r\n  if (cached) {\r\n    console.log(LOG_PREFIX, \"Cache hit for:\", message.badgeId);\r\n    sendResponse({ ...cached, badgeId: message.badgeId, imageUrl: normalizedUrl });\r\n    return;\r\n  }\r\n\r\n  const existing = pendingRequests.get(normalizedUrl);\r\n  if (existing) {\r\n    console.log(LOG_PREFIX, \"Joining existing request for:\", message.badgeId);\r\n    existing.resolvers.push({ badgeId: message.badgeId, sendResponse });\r\n    return;\r\n  }\r\n\r\n  console.log(LOG_PREFIX, \"Queueing new request for:\", message.badgeId);\r\n  pendingRequests.set(normalizedUrl, { resolvers: [{ badgeId: message.badgeId, sendResponse }] });\r\n  detectionQueue.push({ imageUrl: normalizedUrl });\r\n  processQueue();\r\n}\r\n\r\nfunction normalizeImageUrl(imageUrl: string, pageUrl: string): string | null {\r\n  if (!imageUrl) {\r\n    return null;\r\n  }\r\n  try {\r\n    return new URL(imageUrl, pageUrl || undefined).toString();\r\n  } catch (error) {\r\n    console.warn(LOG_PREFIX, \"Invalid image URL\", imageUrl, error);\r\n    return null;\r\n  }\r\n}\r\n\r\nfunction getCachedResult(imageUrl: string): DetectionResponsePayload | null {\r\n  const entry = cache.get(imageUrl);\r\n  if (!entry) {\r\n    return null;\r\n  }\r\n  if (Date.now() - entry.timestamp > REQUEST_TTL_MS) {\r\n    cache.delete(imageUrl);\r\n    return null;\r\n  }\r\n  return entry.payload;\r\n}\r\n\r\nfunction processQueue() {\r\n  if (Date.now() < nextAllowedTimestamp) {\r\n    console.log(LOG_PREFIX, \"Rate limited, waiting...\");\r\n    return;\r\n  }\r\n\r\n  while (runningDetections < MAX_CONCURRENT_DETECTIONS && detectionQueue.length > 0) {\r\n    const job = detectionQueue.shift();\r\n    if (!job) {\r\n      continue;\r\n    }\r\n    runningDetections += 1;\r\n    console.log(LOG_PREFIX, `Processing queue (${runningDetections}/${MAX_CONCURRENT_DETECTIONS} running, ${detectionQueue.length} pending)`);\r\n\r\n    runDetection(job.imageUrl)\r\n      .catch(() => {\r\n        // Individual errors are handled inside runDetection.\r\n      })\r\n      .finally(() => {\r\n        runningDetections -= 1;\r\n        processQueue();\r\n      });\r\n  }\r\n}\r\n\r\nasync function runDetection(imageUrl: string) {\r\n  const { imagionApiKey, imagionDetectionEndpoint } = await getConfig();\r\n\r\n  if (!imagionApiKey) {\r\n    console.warn(LOG_PREFIX, \"No API key configured\");\r\n    recordTelemetry({\r\n      level: \"warning\",\r\n      message: \"missing_api_key\",\r\n      details: { imageUrl },\r\n    });\r\n    dispatchResponse(imageUrl, {\r\n      status: \"missing-key\",\r\n      message: \"Please provide an Imagion API key in the options page.\",\r\n    });\r\n    return;\r\n  }\r\n\r\n  let blob: Blob;\n  try {\n    console.log(LOG_PREFIX, \"Fetching image:\", imageUrl.substring(0, 80));\n    blob = await fetchImageBytes(imageUrl);\n    console.log(LOG_PREFIX, \"Image fetched, size:\", blob.size, \"bytes\");\n  } catch (error) {\n    console.error(LOG_PREFIX, \"Failed to fetch image:\", error);\r\n    recordTelemetry({\r\n      level: \"error\",\r\n      message: \"fetch_image_failed\",\r\n      details: { imageUrl, error: error instanceof Error ? error.message : String(error) },\r\n    });\r\n    dispatchResponse(imageUrl, {\n      status: \"error\",\n      message: error instanceof Error ? error.message : \"Unable to fetch the image.\",\n    });\n    return;\n  }\n\n  let imageHash: string | null = null;\n  try {\n    imageHash = await hashBlobSHA256(blob);\n  } catch (hashError) {\n    console.warn(LOG_PREFIX, \"Failed to hash image:\", hashError);\n  }\n\n  if (imageHash) {\n    const historyEntry = await findHashHistoryEntry(imageHash);\n    if (historyEntry) {\n      recordTelemetry({\n        level: \"info\",\n        message: \"local_history_hit\",\n        details: { imageUrl, hash: imageHash },\n      });\n      cache.set(imageUrl, { timestamp: Date.now(), payload: historyEntry.payload });\n      dispatchResponse(imageUrl, historyEntry.payload);\n      return;\n    }\n  }\n\n  const cacheLookupEndpoint = getCacheLookupEndpoint(imagionDetectionEndpoint);\n  if (imageHash && imagionApiKey) {\n    const remotePayload = await lookupBackendHash(imageHash, cacheLookupEndpoint, imagionApiKey);\n    if (remotePayload) {\n      recordTelemetry({\n        level: \"info\",\n        message: \"remote_cache_hit\",\n        details: { imageUrl, hash: imageHash },\n      });\n      cache.set(imageUrl, { timestamp: Date.now(), payload: remotePayload });\n      void recordHashHistory(imageHash, remotePayload);\n      dispatchResponse(imageUrl, remotePayload);\n      return;\n    }\n  }\n\n  const formData = new FormData();\n  const fileName = extractFileName(imageUrl);\n  const file = new File([blob], fileName, { type: blob.type || \"image/jpeg\" });\r\n  formData.append(\"file\", file);\r\n\r\n  let response: Response;\r\n  try {\r\n    console.log(LOG_PREFIX, \"Sending to API:\", imagionDetectionEndpoint);\r\n    response = await fetch(imagionDetectionEndpoint, {\n      method: \"POST\",\n      headers: {\n        \"x-api-key\": imagionApiKey,\n        \"x-detection-source\": \"extension\",\n      },\n      body: formData,\n    });\n    console.log(LOG_PREFIX, \"API response status:\", response.status);\r\n  } catch (error) {\r\n    console.error(LOG_PREFIX, \"API request failed:\", error);\r\n    recordTelemetry({\r\n      level: \"error\",\r\n      message: \"detection_request_failed\",\r\n      details: { imageUrl, error: error instanceof Error ? error.message : String(error) },\r\n    });\r\n    dispatchResponse(imageUrl, {\r\n      status: \"error\",\r\n      message: error instanceof Error ? error.message : \"Detection request failed.\",\r\n    });\r\n    return;\r\n  }\r\n\r\n  let payload: unknown;\r\n  try {\r\n    payload = await response.json();\r\n    console.log(LOG_PREFIX, \"API response payload:\", payload);\r\n  } catch (error) {\r\n    console.error(LOG_PREFIX, \"Failed to parse JSON:\", error);\r\n    recordTelemetry({\r\n      level: \"error\",\r\n      message: \"invalid_json\",\r\n      details: { imageUrl, error: error instanceof Error ? error.message : String(error) },\r\n    });\r\n    dispatchResponse(imageUrl, {\r\n      status: \"error\",\r\n      message: error instanceof Error ? error.message : \"Unable to parse detection response.\",\r\n    });\r\n    return;\r\n  }\r\n\r\n  if (response.status === 429) {\n    const rateLimitBody = payload as {\n      message?: string;\n      badgeLabel?: string;\n      retryAfter?: number;\n    };\n    const headerRetry = parseRetryAfter(response.headers.get(\"Retry-After\"));\n    const effectiveRetryAfter = rateLimitBody.retryAfter ?? headerRetry;\n    applyRateLimitBackoff(effectiveRetryAfter);\n    console.warn(LOG_PREFIX, \"Rate limited, retry after:\", effectiveRetryAfter, \"seconds\");\n    recordTelemetry({\n      level: \"warning\",\n      message: \"rate_limited\",\n      details: { imageUrl, retryAfter: effectiveRetryAfter, badgeLabel: rateLimitBody.badgeLabel },\n    });\n    dispatchResponse(imageUrl, {\n      status: \"rate-limit\",\n      message: rateLimitBody.message ?? `Rate limit exceeded. Retrying in ${effectiveRetryAfter} seconds.`,\n      retryAfterSeconds: effectiveRetryAfter,\n      badgeLabel: rateLimitBody.badgeLabel,\n    });\n    return;\n  }\n\r\n  if (!response.ok) {\r\n    const message = (payload as { message?: string })?.message || \"Detection failed\";\r\n    console.error(LOG_PREFIX, \"API error:\", response.status, message);\r\n    recordTelemetry({\r\n      level: \"error\",\r\n      message: \"detection_error\",\r\n      details: { imageUrl, responseStatus: response.status, message },\r\n    });\r\n    dispatchResponse(imageUrl, {\r\n      status: \"error\",\r\n      message,\r\n    });\r\n    return;\r\n  }\r\n\r\n  const structuredPayload = payload as {\r\n    verdict?: string;\r\n    score?: number;\r\n    confidence?: number;\r\n    presentation?: string;\r\n  };\r\n\r\n  const successPayload: DetectionResponsePayload = {\n    status: \"success\",\n    verdict: structuredPayload.verdict,\n    score: structuredPayload.score,\n    confidence: structuredPayload.confidence,\n    presentation: structuredPayload.presentation,\n  };\n\n  console.log(LOG_PREFIX, \"Detection success:\", structuredPayload.verdict, \"score:\", structuredPayload.score);\n  recordTelemetry({\n    level: \"info\",\n    message: \"detection_success\",\n    details: { imageUrl, score: structuredPayload.score, verdict: structuredPayload.verdict },\n  });\n\n  cache.set(imageUrl, { timestamp: Date.now(), payload: successPayload });\n  if (imageHash) {\n    void recordHashHistory(imageHash, successPayload);\n  }\n  dispatchResponse(imageUrl, successPayload);\n}\n\r\nasync function fetchImageBytes(url: string): Promise<Blob> {\r\n  const response = await fetch(url, {\r\n    method: \"GET\",\r\n    credentials: \"omit\",\r\n  });\r\n\r\n  if (!response.ok) {\r\n    throw new Error(`Unable to fetch image (${response.status})`);\r\n  }\r\n\r\n  const blob = await response.blob();\r\n  if (!blob || blob.size === 0) {\r\n    throw new Error(\"Image payload was empty.\");\r\n  }\r\n\r\n  return blob;\r\n}\r\n\r\nfunction extractFileName(url: string): string {\r\n  try {\r\n    const parsed = new URL(url);\r\n    const pieces = parsed.pathname.split(\"/\").filter(Boolean);\r\n    const lastSegment = pieces[pieces.length - 1];\r\n    return lastSegment || \"imagion-image.jpg\";\r\n  } catch {\r\n    return \"imagion-image.jpg\";\r\n  }\r\n}\r\n\r\nfunction dispatchResponse(imageUrl: string, payload: DetectionResponsePayload) {\r\n  const entry = pendingRequests.get(imageUrl);\r\n  if (!entry) {\r\n    return;\r\n  }\r\n  console.log(LOG_PREFIX, \"Dispatching response to\", entry.resolvers.length, \"resolver(s)\");\r\n  entry.resolvers.forEach(({ badgeId, sendResponse }) => {\r\n    sendResponse({ ...payload, badgeId, imageUrl });\r\n  });\r\n  pendingRequests.delete(imageUrl);\r\n}\r\n\r\nfunction parseRetryAfter(header: string | null): number {\r\n  if (!header) {\r\n    return BACKOFF_MIN_MS / 1000;\r\n  }\r\n  const parsed = Number.parseInt(header, 10);\r\n  if (Number.isFinite(parsed) && parsed > 0) {\r\n    return parsed;\r\n  }\r\n  return BACKOFF_MIN_MS / 1000;\r\n}\r\n\r\nfunction applyRateLimitBackoff(seconds: number) {\n  const waitMs = Math.min(Math.max(seconds * 1000, BACKOFF_MIN_MS), BACKOFF_MAX_MS);\n  nextAllowedTimestamp = Date.now() + waitMs;\n  if (backoffTimer) {\n    clearTimeout(backoffTimer);\n  }\n  backoffTimer = setTimeout(() => {\n    nextAllowedTimestamp = 0;\n    backoffTimer = null;\n    processQueue();\n  }, waitMs);\n}\n\nasync function loadHashHistory(): Promise<void> {\n  return new Promise((resolve) => {\n    chrome.storage.local.get(HASH_HISTORY_KEY, (items) => {\n      const stored = items[HASH_HISTORY_KEY];\n      if (Array.isArray(stored)) {\n        hashHistory = stored.filter(isHashHistoryEntry);\n        if (hashHistory.length > MAX_HASH_HISTORY) {\n          hashHistory = hashHistory.slice(0, MAX_HASH_HISTORY);\n        }\n      } else {\n        hashHistory = [];\n      }\n      resolve();\n    });\n  });\n}\n\nasync function ensureHashHistoryLoaded(): Promise<void> {\n  await hashHistoryReady;\n}\n\nasync function findHashHistoryEntry(hash: string): Promise<HashHistoryEntry | undefined> {\n  await ensureHashHistoryLoaded();\n  return hashHistory.find((entry) => entry.hash === hash);\n}\n\nasync function recordHashHistory(hash: string, payload: DetectionResponsePayload): Promise<void> {\n  await ensureHashHistoryLoaded();\n  hashHistory = hashHistory.filter((entry) => entry.hash !== hash);\n  hashHistory.unshift({ hash, payload, createdAt: Date.now() });\n  if (hashHistory.length > MAX_HASH_HISTORY) {\n    hashHistory.length = MAX_HASH_HISTORY;\n  }\n  persistHashHistory();\n}\n\nfunction persistHashHistory() {\n  chrome.storage.local.set({ [HASH_HISTORY_KEY]: hashHistory });\n}\n\nfunction isHashHistoryEntry(value: unknown): value is HashHistoryEntry {\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  const entry = value as HashHistoryEntry;\n  return (\n    typeof entry.hash === \"string\" &&\n    entry.hash.length > 0 &&\n    typeof entry.createdAt === \"number\" &&\n    typeof entry.payload === \"object\" &&\n    entry.payload !== null &&\n    typeof entry.payload.status === \"string\"\n  );\n}\n\nasync function hashBlobSHA256(blob: Blob): Promise<string> {\n  const arrayBuffer = await blob.arrayBuffer();\n  const digest = await crypto.subtle.digest(\"SHA-256\", arrayBuffer);\n  const hashArray = Array.from(new Uint8Array(digest));\n  return hashArray.map((byte) => byte.toString(16).padStart(2, \"0\")).join(\"\");\n}\n\nfunction getCacheLookupEndpoint(endpoint: string) {\n  try {\n    const url = new URL(endpoint);\n    if (url.pathname.endsWith(\"/api/detect\")) {\n      url.pathname = url.pathname.replace(/\\/api\\/detect$/, \"/api/cache/hash\");\n    } else {\n      url.pathname = `${url.pathname.replace(/\\/$/, \"\")}/api/cache/hash`;\n    }\n    return url.toString();\n  } catch {\n    const normalized = endpoint.replace(/\\/$/, \"\");\n    return `${normalized}/api/cache/hash`;\n  }\n}\n\nasync function lookupBackendHash(\n  hash: string,\n  endpoint: string,\n  apiKey: string\n): Promise<DetectionResponsePayload | null> {\n  try {\n    const response = await fetch(endpoint, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"x-api-key\": apiKey,\n      },\n      body: JSON.stringify({ hash }),\n    });\n    if (!response.ok) {\n      return null;\n    }\n    const data = await response.json();\n    if (data?.found && data.payload) {\n      return data.payload;\n    }\n  } catch (error) {\n    console.warn(LOG_PREFIX, \"Backend cache lookup failed:\", error);\n  }\n  return null;\n}\n\nfunction recordTelemetry(entry: Omit<TelemetryEntry, \"timestamp\">) {\n  telemetryEntries.push({ timestamp: Date.now(), ...entry });\n  if (telemetryEntries.length > TELEMETRY_LIMIT) {\r\n    telemetryEntries.shift();\r\n  }\r\n  chrome.storage.local.set({ [TELEMETRY_KEY]: telemetryEntries });\r\n}\r\n"],"names":["LOG_PREFIX","DEFAULT_DETECTION_ENDPOINT","TELEMETRY_KEY","HASH_HISTORY_KEY","cache","pendingRequests","detectionQueue","telemetryEntries","runningDetections","cachedConfig","nextAllowedTimestamp","backoffTimer","hashHistory","hashHistoryReady","loadHashHistory","getConfig","config","resolve","items","changes","areaName","message","_sender","sendResponse","handleImageDetection","normalizedUrl","normalizeImageUrl","cached","getCachedResult","existing","processQueue","imageUrl","pageUrl","error","entry","job","runDetection","imagionApiKey","imagionDetectionEndpoint","recordTelemetry","dispatchResponse","blob","fetchImageBytes","imageHash","hashBlobSHA256","hashError","historyEntry","findHashHistoryEntry","cacheLookupEndpoint","getCacheLookupEndpoint","remotePayload","lookupBackendHash","recordHashHistory","formData","fileName","extractFileName","file","response","payload","rateLimitBody","headerRetry","parseRetryAfter","effectiveRetryAfter","applyRateLimitBackoff","structuredPayload","successPayload","url","pieces","badgeId","header","parsed","seconds","waitMs","stored","isHashHistoryEntry","ensureHashHistoryLoaded","hash","persistHashHistory","value","arrayBuffer","digest","byte","endpoint","apiKey","data"],"mappings":"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"}