{"version":3,"file":"background.js","sources":["../src/background.ts"],"sourcesContent":["const LOG_PREFIX = \"[Imagion Background]\";\nconst DEFAULT_DETECTION_ENDPOINT = \"http://localhost:3000/api/detect\";\nconst REQUEST_TTL_MS = 5 * 60 * 1000;\nconst MAX_CONCURRENT_DETECTIONS = 3;\nconst TELEMETRY_KEY = \"imagionTelemetry\";\nconst TELEMETRY_LIMIT = 40;\nconst BACKOFF_MIN_MS = 15000;\nconst BACKOFF_MAX_MS = 60000;\nconst HASH_HISTORY_KEY = \"recentImageHistory\";\nconst MAX_HASH_HISTORY = 250;\nconst RATE_LIMIT_INDICATOR_KEY = \"imagionRateLimitState\";\nconst RATE_LIMIT_BADGE_TEXT = \"!\";\nconst RATE_LIMIT_BADGE_COLOR = \"#ff4d67\";\nconst USAGE_STATUS_MESSAGE = \"REQUEST_USAGE_STATUS\";\n\nconsole.info(LOG_PREFIX, \"Service worker started\");\n\ntype ImagionConfig = {\n  imagionApiKey: string;\n  imagionDetectionEndpoint: string;\n};\n\ntype DetectionResponsePayload = {\n  status: \"success\" | \"missing-key\" | \"error\" | \"rate-limit\";\n  verdict?: string;\n  score?: number;\n  confidence?: number;\n  presentation?: string;\n  errorType?: string;\n  message?: string;\n  badgeLabel?: string;\n  retryAfterSeconds?: number;\n};\n\ntype HashHistoryEntry = {\n  hash: string;\n  payload: DetectionResponsePayload;\n  createdAt: number;\n};\n\ntype DetectionResponse = DetectionResponsePayload & {\n  badgeId: string;\n  imageUrl: string;\n  hash?: string;\n};\n\ntype PendingResolver = {\n  badgeId: string;\n  sendResponse: (response: DetectionResponse) => void;\n};\n\ntype PendingRequest = {\n  resolvers: PendingResolver[];\n};\n\ntype TelemetryEntry = {\n  timestamp: number;\n  level: \"info\" | \"warning\" | \"error\";\n  message: string;\n  details?: Record<string, unknown>;\n};\n\ntype RateLimitReason = \"burst\" | \"daily\" | \"plan\";\ntype RateLimitIndicator = {\n  reason: RateLimitReason;\n  expiresAt: number;\n};\n\ntype UsageStatusPayload = {\n  tier: string;\n  dailyUsed: number;\n  monthlyUsed: number;\n  dailyLimit: number | null;\n  monthlyLimit: number | null;\n  totalDetections: number;\n  monthlyResetAt: string;\n  dailyResetAt: string;\n};\n\nconst cache = new Map<string, { timestamp: number; payload: DetectionResponsePayload }>();\nconst pendingRequests = new Map<string, PendingRequest>();\nconst detectionQueue: Array<{ imageUrl: string }> = [];\nconst telemetryEntries: TelemetryEntry[] = [];\nlet runningDetections = 0;\nlet cachedConfig: ImagionConfig | null = null;\nlet nextAllowedTimestamp = 0;\nlet backoffTimer: ReturnType<typeof setTimeout> | null = null;\nlet hashHistory: HashHistoryEntry[] = [];\nconst hashHistoryReady = loadHashHistory();\nlet rateLimitIndicator: RateLimitIndicator | null = null;\nloadRateLimitIndicator();\n\nasync function getConfig(): Promise<ImagionConfig> {\n  if (cachedConfig) {\n    return cachedConfig;\n  }\n\n  const config = await new Promise<ImagionConfig>((resolve) => {\n    chrome.storage.local.get(\n      {\n        imagionApiKey: \"\",\n        imagionDetectionEndpoint: DEFAULT_DETECTION_ENDPOINT,\n      },\n      (items) => {\n        resolve({\n          imagionApiKey: typeof items.imagionApiKey === \"string\" ? items.imagionApiKey.trim() : \"\",\n          imagionDetectionEndpoint:\n            typeof items.imagionDetectionEndpoint === \"string\" && items.imagionDetectionEndpoint.trim().length > 0\n              ? items.imagionDetectionEndpoint.trim()\n              : DEFAULT_DETECTION_ENDPOINT,\n        });\n      }\n    );\n  });\n\n  cachedConfig = config;\n  console.info(LOG_PREFIX, \"Config loaded:\", {\n    hasApiKey: !!config.imagionApiKey,\n    endpoint: config.imagionDetectionEndpoint,\n  });\n  return config;\n}\n\n  chrome.storage.onChanged.addListener((changes, areaName) => {\n    if (areaName !== \"local\") {\n      return;\n    }\n    if (changes.imagionApiKey || changes.imagionDetectionEndpoint) {\n      console.info(LOG_PREFIX, \"Config changed, clearing cache\");\n      cachedConfig = null;\n      if (changes.imagionApiKey && !changes.imagionApiKey.newValue) {\n        setRateLimitIndicator(null);\n      }\n    }\n  });\n\nchrome.runtime.onMessage.addListener((message, _sender, sendResponse) => {\n  if (!message || typeof message.type !== \"string\") {\n    return false;\n  }\n\n  if (message.type === \"REQUEST_DETECTION\") {\n    console.debug(LOG_PREFIX, \"Received detection request:\", message.badgeId, message.imageUrl?.substring(0, 80));\n    handleImageDetection(message, sendResponse);\n    return true;\n  }\n\n  if (message.type === USAGE_STATUS_MESSAGE) {\n    void (async () => {\n      try {\n        const usage = await fetchUsageStatus();\n        sendResponse({ success: true, usage });\n      } catch (error) {\n        console.error(LOG_PREFIX, \"Usage status failed:\", error);\n        sendResponse({\n          success: false,\n          error: error instanceof Error ? error.message : \"Failed to load usage status\",\n        });\n      }\n    })();\n    return true;\n  }\n\n  return false;\n});\n\nfunction handleImageDetection(message: {\n  type: \"REQUEST_DETECTION\";\n  imageUrl: string;\n  badgeId: string;\n  pageUrl: string;\n}, sendResponse: (response: DetectionResponse) => void) {\n  const normalizedUrl = normalizeImageUrl(message.imageUrl, message.pageUrl);\n  if (!normalizedUrl) {\n    console.warn(LOG_PREFIX, \"Invalid URL:\", message.imageUrl);\n    sendResponse({\n      status: \"error\",\n      message: \"Unable to resolve image URL.\",\n      badgeId: message.badgeId,\n      imageUrl: message.imageUrl,\n    });\n    return;\n  }\n\n  const cached = getCachedResult(normalizedUrl);\n  if (cached) {\n    console.debug(LOG_PREFIX, \"Cache hit for:\", message.badgeId);\n    sendResponse({ ...cached, badgeId: message.badgeId, imageUrl: normalizedUrl });\n    return;\n  }\n\n  const existing = pendingRequests.get(normalizedUrl);\n  if (existing) {\n    console.debug(LOG_PREFIX, \"Joining existing request for:\", message.badgeId);\n    existing.resolvers.push({ badgeId: message.badgeId, sendResponse });\n    return;\n  }\n\n  console.debug(LOG_PREFIX, \"Queueing new request for:\", message.badgeId);\n  pendingRequests.set(normalizedUrl, { resolvers: [{ badgeId: message.badgeId, sendResponse }] });\n  detectionQueue.push({ imageUrl: normalizedUrl });\n  processQueue();\n}\n\nfunction normalizeImageUrl(imageUrl: string, pageUrl: string): string | null {\n  if (!imageUrl) {\n    return null;\n  }\n  try {\n    return new URL(imageUrl, pageUrl || undefined).toString();\n  } catch (error) {\n    console.warn(LOG_PREFIX, \"Invalid image URL\", imageUrl, error);\n    return null;\n  }\n}\n\nfunction getCachedResult(imageUrl: string): DetectionResponsePayload | null {\n  const entry = cache.get(imageUrl);\n  if (!entry) {\n    return null;\n  }\n  if (Date.now() - entry.timestamp > REQUEST_TTL_MS) {\n    cache.delete(imageUrl);\n    return null;\n  }\n  return entry.payload;\n}\n\nfunction processQueue() {\n  if (Date.now() < nextAllowedTimestamp) {\n    console.debug(LOG_PREFIX, \"Rate limited, waiting...\");\n    return;\n  }\n\n  while (runningDetections < MAX_CONCURRENT_DETECTIONS && detectionQueue.length > 0) {\n    const job = detectionQueue.shift();\n    if (!job) {\n      continue;\n    }\n    runningDetections += 1;\n    console.debug(LOG_PREFIX, `Processing queue (${runningDetections}/${MAX_CONCURRENT_DETECTIONS} running, ${detectionQueue.length} pending)`);\n\n    runDetection(job.imageUrl)\n      .catch(() => {\n        // Individual errors are handled inside runDetection.\n      })\n      .finally(() => {\n        runningDetections -= 1;\n        processQueue();\n      });\n  }\n}\n\nasync function runDetection(imageUrl: string) {\n  const { imagionApiKey, imagionDetectionEndpoint } = await getConfig();\n\n  if (!imagionApiKey) {\n    console.warn(LOG_PREFIX, \"No API key configured\");\n    recordTelemetry({\n      level: \"warning\",\n      message: \"missing_api_key\",\n      details: { imageUrl },\n    });\n    dispatchResponse(imageUrl, {\n      status: \"missing-key\",\n      message: \"Please provide an Imagion API key in the options page.\",\n    });\n    return;\n  }\n\n  let blob: Blob;\n  try {\n    console.debug(LOG_PREFIX, \"Fetching image:\", imageUrl.substring(0, 80));\n    blob = await fetchImageBytes(imageUrl);\n    console.debug(LOG_PREFIX, \"Image fetched, size:\", blob.size, \"bytes\");\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    console.error(LOG_PREFIX, \"Failed to fetch image:\", {\n      imageUrl,\n      error: errorMessage,\n      errorType: error instanceof Error ? error.name : typeof error,\n      stack: error instanceof Error ? error.stack : undefined,\n    });\n    recordTelemetry({\n      level: \"error\",\n      message: \"fetch_image_failed\",\n      details: { imageUrl, error: errorMessage },\n    });\n    dispatchResponse(imageUrl, {\n      status: \"error\",\n      message: `Failed to fetch image: ${errorMessage}`,\n    });\n    return;\n  }\n\n  let imageHash: string | null = null;\n  try {\n    imageHash = await hashBlobSHA256(blob);\n  } catch (hashError) {\n    console.warn(LOG_PREFIX, \"Failed to hash image:\", hashError);\n  }\n\n  if (imageHash) {\n    const historyEntry = await findHashHistoryEntry(imageHash);\n    if (historyEntry) {\n      recordTelemetry({\n        level: \"info\",\n        message: \"local_history_hit\",\n        details: { imageUrl, hash: imageHash },\n      });\n      // Ensure status is set for cached responses\n      const payload = { ...historyEntry.payload, status: historyEntry.payload.status || \"success\" as const };\n      cache.set(imageUrl, { timestamp: Date.now(), payload });\n      dispatchResponse(imageUrl, payload, imageHash);\n      return;\n    }\n  }\n\n  const cacheLookupEndpoint = getCacheLookupEndpoint(imagionDetectionEndpoint);\n  if (imageHash && imagionApiKey) {\n    const remotePayload = await lookupBackendHash(imageHash, cacheLookupEndpoint, imagionApiKey);\n    if (remotePayload) {\n      recordTelemetry({\n        level: \"info\",\n        message: \"remote_cache_hit\",\n        details: { imageUrl, hash: imageHash },\n      });\n      // Ensure status is set for cached responses\n      const payload = { ...remotePayload, status: remotePayload.status || \"success\" as const };\n      cache.set(imageUrl, { timestamp: Date.now(), payload });\n      void recordHashHistory(imageHash, payload);\n      dispatchResponse(imageUrl, payload, imageHash);\n      return;\n    }\n  }\n\n  const formData = new FormData();\n  const fileName = extractFileName(imageUrl);\n  const file = new File([blob], fileName, { type: blob.type || \"image/jpeg\" });\n  formData.append(\"file\", file);\n\n  let response: Response;\n  try {\n    console.debug(LOG_PREFIX, \"Sending to API:\", imagionDetectionEndpoint);\n    response = await fetch(imagionDetectionEndpoint, {\n      method: \"POST\",\n      headers: {\n        \"x-api-key\": imagionApiKey,\n        \"x-detection-source\": \"extension\",\n      },\n      body: formData,\n    });\n    console.debug(LOG_PREFIX, \"API response status:\", response.status);\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    console.error(LOG_PREFIX, \"API request failed:\", {\n      imageUrl,\n      endpoint: imagionDetectionEndpoint,\n      error: errorMessage,\n      errorType: error instanceof Error ? error.name : typeof error,\n      stack: error instanceof Error ? error.stack : undefined,\n    });\n    recordTelemetry({\n      level: \"error\",\n      message: \"detection_request_failed\",\n      details: { imageUrl, error: errorMessage },\n    });\n    dispatchResponse(imageUrl, {\n      status: \"error\",\n      message: `API request failed: ${errorMessage}`,\n    }, imageHash ?? undefined);\n    return;\n  }\n\n  let payload: unknown;\n  try {\n    payload = await response.json();\n    console.debug(LOG_PREFIX, \"API response payload:\", payload);\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    console.error(LOG_PREFIX, \"Failed to parse API response JSON:\", {\n      imageUrl,\n      status: response.status,\n      statusText: response.statusText,\n      contentType: response.headers.get(\"content-type\"),\n      error: errorMessage,\n    });\n    recordTelemetry({\n      level: \"error\",\n      message: \"invalid_json\",\n      details: { imageUrl, status: response.status, error: errorMessage },\n    });\n    dispatchResponse(imageUrl, {\n      status: \"error\",\n      message: `Failed to parse response (status ${response.status}): ${errorMessage}`,\n    }, imageHash ?? undefined);\n    return;\n  }\n\n  if (response.status === 429) {\n    const rateLimitBody = payload as {\n      message?: string;\n      badgeLabel?: string;\n      retryAfter?: number;\n      errorType?: string;\n    };\n    const headerRetry = parseRetryAfter(response.headers.get(\"Retry-After\"));\n    const effectiveRetryAfter = rateLimitBody.retryAfter ?? headerRetry;\n    const limitReason: RateLimitReason =\n      rateLimitBody.errorType === \"PLAN_LIMIT_EXCEEDED\"\n        ? \"plan\"\n        : rateLimitBody.errorType === \"DAILY_RATE_LIMIT_EXCEEDED\"\n          ? \"daily\"\n          : \"burst\";\n    applyRateLimitBackoff(effectiveRetryAfter, limitReason);\n    console.warn(LOG_PREFIX, \"Rate limited, retry after:\", effectiveRetryAfter, \"seconds\");\n    recordTelemetry({\n      level: \"warning\",\n      message: \"rate_limited\",\n      details: {\n        imageUrl,\n        retryAfter: effectiveRetryAfter,\n        badgeLabel: rateLimitBody.badgeLabel,\n        errorType: rateLimitBody.errorType,\n      },\n    });\n    dispatchResponse(imageUrl, {\n      status: \"rate-limit\",\n      message: rateLimitBody.message ?? `Rate limit exceeded. Retrying in ${effectiveRetryAfter} seconds.`,\n      retryAfterSeconds: effectiveRetryAfter,\n      badgeLabel: rateLimitBody.badgeLabel,\n      errorType: rateLimitBody.errorType,\n    }, imageHash ?? undefined);\n    return;\n  }\n\n  if (!response.ok) {\n    const errorBody = payload as { message?: string; error?: string; details?: unknown };\n    const message = errorBody.message || errorBody.error || \"Detection failed\";\n    console.error(LOG_PREFIX, \"API error response:\", {\n      status: response.status,\n      statusText: response.statusText,\n      message,\n      imageUrl,\n      fullResponse: errorBody,\n    });\n    recordTelemetry({\n      level: \"error\",\n      message: \"detection_error\",\n      details: { imageUrl, responseStatus: response.status, message, fullResponse: errorBody },\n    });\n    dispatchResponse(imageUrl, {\n      status: \"error\",\n      message,\n    }, imageHash ?? undefined);\n    return;\n  }\n\n  const structuredPayload = payload as {\n    verdict?: string;\n    score?: number;\n    confidence?: number;\n    presentation?: string;\n    message?: string;\n    error?: string;\n  };\n\n  // If no verdict, treat as error\n  if (!structuredPayload.verdict) {\n    const errorMessage = structuredPayload.message || structuredPayload.error || \"API returned no verdict. The image may be unsupported or corrupted.\";\n    console.error(LOG_PREFIX, \"API returned success but no verdict:\", {\n      imageUrl,\n      responseStatus: response.status,\n      payload: structuredPayload,\n      rawPayload: payload,\n    });\n    recordTelemetry({\n      level: \"error\",\n      message: \"no_verdict_returned\",\n      details: { imageUrl, responseStatus: response.status, rawPayload: payload },\n    });\n    dispatchResponse(imageUrl, {\n      status: \"error\",\n      message: errorMessage,\n    }, imageHash ?? undefined);\n    return;\n  }\n\n  const successPayload: DetectionResponsePayload = {\n    status: \"success\",\n    verdict: structuredPayload.verdict,\n    score: structuredPayload.score,\n    confidence: structuredPayload.confidence,\n    presentation: structuredPayload.presentation,\n  };\n\n  console.info(LOG_PREFIX, \"Detection success:\", structuredPayload.verdict, \"score:\", structuredPayload.score);\n  recordTelemetry({\n    level: \"info\",\n    message: \"detection_success\",\n    details: { imageUrl, score: structuredPayload.score, verdict: structuredPayload.verdict },\n  });\n\n  cache.set(imageUrl, { timestamp: Date.now(), payload: successPayload });\n  if (imageHash) {\n    void recordHashHistory(imageHash, successPayload);\n  }\n  dispatchResponse(imageUrl, successPayload, imageHash ?? undefined);\n}\n\nasync function fetchImageBytes(url: string): Promise<Blob> {\n  const response = await fetch(url, {\n    method: \"GET\",\n    credentials: \"omit\",\n  });\n\n  if (!response.ok) {\n    throw new Error(`Unable to fetch image (${response.status})`);\n  }\n\n  const blob = await response.blob();\n  if (!blob || blob.size === 0) {\n    throw new Error(\"Image payload was empty.\");\n  }\n\n  return blob;\n}\n\nfunction extractFileName(url: string): string {\n  try {\n    const parsed = new URL(url);\n    const pieces = parsed.pathname.split(\"/\").filter(Boolean);\n    const lastSegment = pieces[pieces.length - 1];\n    return lastSegment || \"imagion-image.jpg\";\n  } catch {\n    return \"imagion-image.jpg\";\n  }\n}\n\nfunction dispatchResponse(imageUrl: string, payload: DetectionResponsePayload, hash?: string) {\n  const entry = pendingRequests.get(imageUrl);\n  if (!entry) {\n    return;\n  }\n  console.debug(LOG_PREFIX, \"Dispatching response to\", entry.resolvers.length, \"resolver(s)\");\n  entry.resolvers.forEach(({ badgeId, sendResponse }) => {\n    sendResponse({ ...payload, badgeId, imageUrl, hash });\n  });\n  pendingRequests.delete(imageUrl);\n}\n\nfunction parseRetryAfter(header: string | null): number {\n  if (!header) {\n    return BACKOFF_MIN_MS / 1000;\n  }\n  const parsed = Number.parseInt(header, 10);\n  if (Number.isFinite(parsed) && parsed > 0) {\n    return parsed;\n  }\n  return BACKOFF_MIN_MS / 1000;\n}\n\nfunction applyRateLimitBackoff(seconds: number, reason: RateLimitReason = \"burst\") {\n  const waitMs = Math.min(Math.max(seconds * 1000, BACKOFF_MIN_MS), BACKOFF_MAX_MS);\n  nextAllowedTimestamp = Date.now() + waitMs;\n  if (backoffTimer) {\n    clearTimeout(backoffTimer);\n  }\n  if (reason === \"plan\") {\n    setRateLimitIndicator({\n      reason,\n      expiresAt: nextAllowedTimestamp,\n    });\n  }\n  backoffTimer = setTimeout(() => {\n    nextAllowedTimestamp = 0;\n    backoffTimer = null;\n    if (reason === \"plan\") {\n      setRateLimitIndicator(null);\n    }\n    processQueue();\n  }, waitMs);\n}\n\nfunction applyLimitBadge(active: boolean) {\n  if (active) {\n    chrome.action.setBadgeText({ text: RATE_LIMIT_BADGE_TEXT });\n    chrome.action.setBadgeBackgroundColor({ color: RATE_LIMIT_BADGE_COLOR });\n  } else {\n    chrome.action.setBadgeText({ text: \"\" });\n    chrome.action.setBadgeBackgroundColor({ color: \"#000000\" });\n  }\n}\n\nfunction persistRateLimitIndicator(state: RateLimitIndicator | null) {\n  if (state) {\n    chrome.storage.local.set({ [RATE_LIMIT_INDICATOR_KEY]: state });\n  } else {\n    chrome.storage.local.remove(RATE_LIMIT_INDICATOR_KEY);\n  }\n}\n\nfunction setRateLimitIndicator(state: RateLimitIndicator | null) {\n  rateLimitIndicator = state;\n  applyLimitBadge(Boolean(state));\n  persistRateLimitIndicator(state);\n}\n\nfunction isRateLimitIndicator(value: unknown): value is RateLimitIndicator {\n  if (!value || typeof value !== \"object\") {\n    return false;\n  }\n  const indicator = value as RateLimitIndicator;\n  return (\n    [\"burst\", \"daily\", \"plan\"].includes(indicator.reason) &&\n    typeof indicator.expiresAt === \"number\" &&\n    Number.isFinite(indicator.expiresAt)\n  );\n}\n\nfunction loadRateLimitIndicator(): Promise<void> {\n  return new Promise((resolve) => {\n    chrome.storage.local.get(RATE_LIMIT_INDICATOR_KEY, (items) => {\n      const stored = items[RATE_LIMIT_INDICATOR_KEY];\n      if (isRateLimitIndicator(stored) && stored.expiresAt > Date.now()) {\n        rateLimitIndicator = stored;\n        applyLimitBadge(true);\n        nextAllowedTimestamp = stored.expiresAt;\n        const waitMs = stored.expiresAt - Date.now();\n        if (waitMs > 0) {\n          backoffTimer = setTimeout(() => {\n            nextAllowedTimestamp = 0;\n            backoffTimer = null;\n            setRateLimitIndicator(null);\n            processQueue();\n          }, waitMs);\n        } else {\n          setRateLimitIndicator(null);\n        }\n      } else {\n        chrome.storage.local.remove(RATE_LIMIT_INDICATOR_KEY);\n      }\n      resolve();\n    });\n  });\n}\n\nasync function loadHashHistory(): Promise<void> {\n  return new Promise((resolve) => {\n    chrome.storage.local.get(HASH_HISTORY_KEY, (items) => {\n      const stored = items[HASH_HISTORY_KEY];\n      if (Array.isArray(stored)) {\n        hashHistory = stored.filter(isHashHistoryEntry);\n        if (hashHistory.length > MAX_HASH_HISTORY) {\n          hashHistory = hashHistory.slice(0, MAX_HASH_HISTORY);\n        }\n      } else {\n        hashHistory = [];\n      }\n      resolve();\n    });\n  });\n}\n\nasync function ensureHashHistoryLoaded(): Promise<void> {\n  await hashHistoryReady;\n}\n\nasync function findHashHistoryEntry(hash: string): Promise<HashHistoryEntry | undefined> {\n  await ensureHashHistoryLoaded();\n  return hashHistory.find((entry) => entry.hash === hash);\n}\n\nasync function recordHashHistory(hash: string, payload: DetectionResponsePayload): Promise<void> {\n  await ensureHashHistoryLoaded();\n  hashHistory = hashHistory.filter((entry) => entry.hash !== hash);\n  hashHistory.unshift({ hash, payload, createdAt: Date.now() });\n  if (hashHistory.length > MAX_HASH_HISTORY) {\n    hashHistory.length = MAX_HASH_HISTORY;\n  }\n  persistHashHistory();\n}\n\nfunction persistHashHistory() {\n  chrome.storage.local.set({ [HASH_HISTORY_KEY]: hashHistory });\n}\n\nfunction isHashHistoryEntry(value: unknown): value is HashHistoryEntry {\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  const entry = value as HashHistoryEntry;\n  return (\n    typeof entry.hash === \"string\" &&\n    entry.hash.length > 0 &&\n    typeof entry.createdAt === \"number\" &&\n    typeof entry.payload === \"object\" &&\n    entry.payload !== null &&\n    typeof entry.payload.status === \"string\"\n  );\n}\n\nasync function hashBlobSHA256(blob: Blob): Promise<string> {\n  const arrayBuffer = await blob.arrayBuffer();\n  const digest = await crypto.subtle.digest(\"SHA-256\", arrayBuffer);\n  const hashArray = Array.from(new Uint8Array(digest));\n  return hashArray.map((byte) => byte.toString(16).padStart(2, \"0\")).join(\"\");\n}\n\nfunction getCacheLookupEndpoint(endpoint: string) {\n  try {\n    const url = new URL(endpoint);\n    if (url.pathname.endsWith(\"/api/detect\")) {\n      url.pathname = url.pathname.replace(/\\/api\\/detect$/, \"/api/cache/hash\");\n    } else {\n      url.pathname = `${url.pathname.replace(/\\/$/, \"\")}/api/cache/hash`;\n    }\n    return url.toString();\n  } catch {\n    const normalized = endpoint.replace(/\\/$/, \"\");\n    return `${normalized}/api/cache/hash`;\n  }\n}\n\nasync function lookupBackendHash(\n  hash: string,\n  endpoint: string,\n  apiKey: string\n): Promise<DetectionResponsePayload | null> {\n  try {\n    const response = await fetch(endpoint, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"x-api-key\": apiKey,\n      },\n      body: JSON.stringify({ hash }),\n    });\n    if (!response.ok) {\n      return null;\n    }\n    const data = await response.json();\n    if (data?.found && data.payload) {\n      return data.payload;\n    }\n  } catch (error) {\n    console.warn(LOG_PREFIX, \"Backend cache lookup failed:\", error);\n  }\n  return null;\n}\n\nfunction getUsageStatusEndpoint(endpoint: string) {\n  try {\n    const url = new URL(endpoint);\n    if (url.pathname.endsWith(\"/api/detect\")) {\n      url.pathname = url.pathname.replace(/\\/api\\/detect$/, \"/api/usage/status\");\n    } else {\n      url.pathname = `${url.pathname.replace(/\\/$/, \"\")}/api/usage/status`;\n    }\n    return url.toString();\n  } catch {\n    const normalized = endpoint.replace(/\\/$/, \"\");\n    return `${normalized}/api/usage/status`;\n  }\n}\n\nasync function fetchUsageStatus(): Promise<UsageStatusPayload> {\n  const { imagionApiKey, imagionDetectionEndpoint } = await getConfig();\n  if (!imagionApiKey) {\n    throw new Error(\"Missing Imagion API key\");\n  }\n\n  const endpoint = getUsageStatusEndpoint(imagionDetectionEndpoint);\n  const response = await fetch(endpoint, {\n    method: \"GET\",\n    headers: {\n      \"x-api-key\": imagionApiKey,\n    },\n  });\n  if (!response.ok) {\n    const bodyText = await response.text();\n    throw new Error(`Usage status request failed (${response.status}): ${bodyText}`);\n  }\n\n  const payload = await response.json();\n  if (!payload?.success || !payload?.usage) {\n    throw new Error(\"Invalid usage status response\");\n  }\n\n  return payload.usage as UsageStatusPayload;\n}\n\nfunction recordTelemetry(entry: Omit<TelemetryEntry, \"timestamp\">) {\n  telemetryEntries.push({ timestamp: Date.now(), ...entry });\n  if (telemetryEntries.length > TELEMETRY_LIMIT) {\n    telemetryEntries.shift();\n  }\n  chrome.storage.local.set({ [TELEMETRY_KEY]: telemetryEntries });\n}\n"],"names":["LOG_PREFIX","DEFAULT_DETECTION_ENDPOINT","TELEMETRY_KEY","HASH_HISTORY_KEY","RATE_LIMIT_INDICATOR_KEY","RATE_LIMIT_BADGE_COLOR","USAGE_STATUS_MESSAGE","cache","pendingRequests","detectionQueue","telemetryEntries","runningDetections","cachedConfig","nextAllowedTimestamp","backoffTimer","hashHistory","hashHistoryReady","loadHashHistory","loadRateLimitIndicator","getConfig","config","resolve","items","changes","areaName","setRateLimitIndicator","message","_sender","sendResponse","handleImageDetection","usage","fetchUsageStatus","error","normalizedUrl","normalizeImageUrl","cached","getCachedResult","existing","processQueue","imageUrl","pageUrl","entry","job","runDetection","imagionApiKey","imagionDetectionEndpoint","recordTelemetry","dispatchResponse","blob","fetchImageBytes","errorMessage","imageHash","hashBlobSHA256","hashError","historyEntry","findHashHistoryEntry","payload","cacheLookupEndpoint","getCacheLookupEndpoint","remotePayload","lookupBackendHash","recordHashHistory","formData","fileName","extractFileName","file","response","rateLimitBody","headerRetry","parseRetryAfter","effectiveRetryAfter","limitReason","applyRateLimitBackoff","errorBody","structuredPayload","successPayload","url","pieces","hash","badgeId","header","parsed","seconds","reason","waitMs","applyLimitBadge","active","persistRateLimitIndicator","state","isRateLimitIndicator","value","indicator","stored","isHashHistoryEntry","ensureHashHistoryLoaded","persistHashHistory","arrayBuffer","digest","byte","endpoint","apiKey","data","getUsageStatusEndpoint","bodyText"],"mappings":"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"}